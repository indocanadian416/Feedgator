
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>FeedGator — Daily Cyber Threat Intel (Secure, Cross‑Platform)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="color-scheme" content="dark light" />
  <style>
    :root {
      --bg: #0f172a; --card: #111827; --ink: #0b1220;
      --text: #e5e7eb; --muted: #9ca3af; --border: #1f2937;
      --accent: #38bdf8; --accent2: #34d399; --danger: #f87171;
      --tag: #93c5fd; --tag2: #fcd34d; --tag3: #fda4af;
    }
    @media (prefers-color-scheme: light) {
      :root {
        --bg: #f8fafc; --card: #ffffff; --ink: #ffffff;
        --text: #0f172a; --muted: #334155; --border: #e2e8f0;
        --accent: #0ea5e9; --accent2: #10b981; --danger: #ef4444;
        --tag: #2563eb1a; --tag2: #ca8a041a; --tag3: #db27771a;
      }
    }

    html, body {
      background: linear-gradient(180deg, var(--ink) 0%, var(--bg) 100%);
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Liberation Sans", sans-serif;
      margin: 0; padding: 0; min-height: 100%;
    }

    header {
      padding: 20px;
      border-bottom: 1px solid var(--border);
      background: color-mix(in oklab, var(--card) 70%, transparent);
      backdrop-filter: blur(4px);
      position: sticky; top: 0; z-index: 999;
    }
    h1 { margin: 0 0 6px; font-size: 1.65rem; letter-spacing: .2px; }
    .subtitle { color: var(--muted); font-size: .95rem; }

    .container { padding: 16px 20px 40px; max-width: 1240px; margin: 0 auto; }

    .panel {
      background: var(--card); border: 1px solid var(--border);
      border-radius: 12px; padding: 12px; margin-bottom: 16px;
    }
    .panel h2 { font-size: 1.06rem; margin: 0 0 8px; color: var(--accent); }

    textarea {
      width: 100%; min-height: 160px; resize: vertical;
      color: var(--text); background: var(--ink);
      border: 1px solid var(--border); border-radius: 10px; padding: 10px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
    }

    .inputs {
      display: grid; grid-template-columns: 1fr 1fr 1fr auto; gap: 8px; margin-top: 8px;
    }
    @media (max-width: 900px) {
      .inputs { grid-template-columns: 1fr; }
    }
    .inputs input, .inputs select {
      width: 100%; color: var(--text); background: var(--ink);
      border: 1px solid var(--border); border-radius: 10px; padding: 8px 10px;
    }

    .btn {
      border: 1px solid var(--border); padding: 10px 14px; border-radius: 10px;
      cursor: pointer; background: var(--ink); color: var(--text); transition: .15s ease; white-space: nowrap;
      user-select: none;
    }
    .btn:hover { border-color: var(--accent); color: var(--accent); }

    /* Primary button — keep text readable on hover */
    .btn-primary {
      background: var(--accent); color: var(--ink); border-color: transparent; font-weight: 600;
    }
    .btn.btn-primary:hover {
      filter: brightness(1.06);
      color: var(--ink) !important; border-color: transparent;
    }

    .btn-success { background: var(--accent2); color: var(--ink); border-color: transparent; font-weight: 600; }
    .btn-danger  { background: var(--danger);  color: var(--ink); border-color: transparent; font-weight: 600; }

    .meta {
      display: flex; gap: 10px; flex-wrap: wrap; margin-top: 8px; color: var(--muted); font-size: .9rem;
    }

    .grid { display: grid; grid-template-columns: 1fr; gap: 12px; margin-top: 12px; }
    @media (min-width: 720px)  { .grid { grid-template-columns: 1fr 1fr; } }
    @media (min-width: 1100px) { .grid { grid-template-columns: 1fr 1fr 1fr; } }

    article.card {
      background: var(--card); border: 1px solid var(--border); border-radius: 12px; padding: 12px;
      display: flex; flex-direction: column; gap: 6px;
    }
    .source { font-size: .85rem; color: var(--muted); }
    .source a { color: inherit; text-decoration: none; border-bottom: 1px dotted transparent; }
    .source a:hover { color: var(--accent); border-color: var(--accent); }

    .card h3 { font-size: 1.05rem; margin: 0; line-height: 1.25; }
    .card h3 a { color: var(--text); text-decoration: none; border-bottom: 1px dashed transparent; }
    .card h3 a:hover { color: var(--accent); border-color: var(--accent); }

    .date { font-size: .82rem; color: var(--muted); }
    .desc { font-size: .94rem; color: color-mix(in oklab, var(--text) 80%, var(--muted)); }

    .tags { display: flex; flex-wrap: wrap; gap: 6px; margin-top: 2px; }
    .tag {
      font-size: .75rem; color: var(--ink);
      background: var(--tag); border-radius: 999px; padding: 2px 8px; border: 1px solid transparent;
    }
    .tag.critical { background: var(--tag3); }
    .tag.high { background: var(--tag2); }

    footer { padding: 26px; color: var(--muted); text-align: center; }
    [aria-busy="true"] { opacity: .85; }
  </style>
</head>
<body>
  <header>
    <h1>FeedGator — Daily Cyber Threat Intel</h1>
    <div class="subtitle">Client‑side • Free RSS API (AllOrigins) • Auto‑refresh • TXT export (titles & links) • Secure & Cross‑Platform</div>
  </header>

  <main class="container">
    <section class="panel" aria-label="Controls">
      <h2>RSS/Atom Feeds (one URL per line)</h2>
      <textarea id="feedList" aria-label="Feed URLs input"></textarea>

      <div class="inputs" role="group" aria-label="Filters and actions">
        <input id="keyword" type="search" placeholder="Filter by keyword (title/summary/source)" aria-label="Keyword filter" />
        <select id="scope" aria-label="Time window">
          <option value="today" selected>Today</option>
          <option value="24h">Last 24 hours</option>
          <option value="48h">Last 48 hours</option>
          <option value="7d">Last 7 days</option>
          <option value="all">All time</option>
        </select>
        <select id="sort" aria-label="Sort mode">
          <option value="priority_date" selected>Cyber priority → Newest</option>
          <option value="newest">Newest first</option>
          <option value="source">By source</option>
          <option value="title">By title</option>
        </select>
        <button class="btn btn-primary" id="loadBtn" title="Load feeds now" aria-label="Load feeds">Load Feeds</button>
      </div>

      <div style="margin-top:10px; display:flex; gap:8px; flex-wrap:wrap;">
        <button class="btn" id="refreshBtn" title="Refresh feeds">Refresh</button>
        <button class="btn btn-success" id="downloadTxtBtn" title="Download TXT (titles + links in scope)">Download TXT (titles + links)</button>
        <button class="btn btn-danger" id="clearCacheBtn" title="Clear local cache">Clear Cache</button>
      </div>

      <div class="meta" aria-live="polite">
        <div>Status: <span id="status">Idle</span></div>
        <div>Last updated: <span id="updatedAt">—</span></div>
        <div>Items in scope: <span id="countInScope">0</span></div>
        <div>Auto‑refresh: <span id="refreshInfo">Every 10 min</span></div>
      </div>
    </section>

    <section id="results" class="grid" aria-live="polite" aria-busy="false" aria-label="Results"></section>
  </main>

  <footer>
    <div>&copy; <span id="year"></span> FeedGator — Secure client‑side, cross‑platform</div>
    <div>created by - Pratik</div>
  </footer>

  <script>
    // ========= Configuration (optimized for speed & coverage) =========
    const CACHE_KEY = 'feedgator_cache_v6';
    const MAX_ITEMS_PER_FEED = 400;     // pull more per feed
    const AUTO_REFRESH_MINUTES = 10;    // faster refresh
    const CONCURRENCY = 12;             // more parallel fetch workers
    const REQUEST_TIMEOUT_MS = 12000;   // per-feed timeout

    // ========= DOM =========
    const dom = {
      feedList: document.getElementById('feedList'),
      keyword: document.getElementById('keyword'),
      scope: document.getElementById('scope'),
      sort: document.getElementById('sort'),
      status: document.getElementById('status'),
      updatedAt: document.getElementById('updatedAt'),
      countInScope: document.getElementById('countInScope'),
      refreshBtn: document.getElementById('refreshBtn'),
      clearCacheBtn: document.getElementById('clearCacheBtn'),
      downloadTxtBtn: document.getElementById('downloadTxtBtn'),
      results: document.getElementById('results'),
      year: document.getElementById('year'),
      refreshInfo: document.getElementById('refreshInfo'),
      loadBtn: document.getElementById('loadBtn')
    };
    dom.year.textContent = new Date().getFullYear();
    dom.refreshInfo.textContent = `Every ${AUTO_REFRESH_MINUTES} min`;
    const setStatus = (txt) => { dom.status.textContent = txt; };

    // ========= Tagging (broad coverage for cyber terms) =========
    const TAGS = [
      { name: 'Ransomware',  weight: 8, keys: ['ransom', 'lockbit', 'blackcat', 'alphv', 'conti', 'revil'] },
      { name: 'Malware',     weight: 6, keys: ['malware', 'trojan', 'worm', 'spyware', 'adware', 'rootkit', 'botnet'] },
      { name: 'Exploit',     weight: 6, keys: ['exploit', 'eop', 'rce', 'lpe', 'remote code execution', 'privilege escalation'] },
      { name: 'CVE',         weight: 6, keys: ['cve-', 'cve '] },
      { name: 'Zero‑Day',    weight: 7, keys: ['zero day', '0day', 'zero‑day'] },
      { name: 'Phishing',    weight: 5, keys: ['phishing', 'spear', 'smishing', 'vishing', 'bec', 'credential theft'] },
      { name: 'Breach',      weight: 5, keys: ['breach', 'data leak', 'leak', 'compromise', 'exfiltration'] },
      { name: 'Patch',       weight: 4, keys: ['patch', 'update', 'security update', 'advisory', 'fix'] },
      { name: 'DDoS',        weight: 4, keys: ['ddos', 'denial of service'] },
      { name: 'APT',         weight: 5, keys: ['apt', 'nation-state', 'state-sponsored'] },
      { name: 'Supply Chain',weight: 5, keys: ['supply chain', 'dependency', 'typosquat', 'package'] },
      { name: 'Backdoor',    weight: 5, keys: ['backdoor', 'webshell'] },
      { name: 'IoC',         weight: 4, keys: ['ioc', 'indicator of compromise'] },
      { name: 'Cloud',       weight: 3, keys: ['aws', 'azure', 'gcp', 'cloud', 'kubernetes', 'container'] },
      { name: 'Identity',    weight: 3, keys: ['okta', 'adfs', 'kerberos', 'ntlm', 'active directory'] },
      { name: 'Network',     weight: 3, keys: ['cisco', 'juniper', 'fortinet', 'palo alto', 'checkpoint'] },
      { name: 'Web Vulns',   weight: 3, keys: ['xss', 'csrf', 'ssrf', 'sql injection', 'path traversal', 'deserialization'] },
      { name: 'Email Threat',weight: 3, keys: ['spam', 'spoofing', 'dmarc', 'spf', 'dkim'] },
      { name: 'Crypto',      weight: 2, keys: ['crypto', 'blockchain'] }
    ];

    function computeTagsAndPriority(text) {
      const t = (text || '').toLowerCase();
      const out = [];
      let score = 0;
      for (const tag of TAGS) {
        let matched = false;
        for (const k of tag.keys) {
          if (t.includes(k)) { matched = true; break; }
        }
        if (matched) { out.push(tag.name); score += tag.weight; }
      }
      return { tags: out, score };
    }

    // ========= Date helpers =========
    function parseDateAuto(str) {
      if (!str) return null;
      const d = new Date(str);
      if (!isNaN(d.getTime())) return d;
      try {
        const cleaned = str.replace(/\s\([A-Za-z]+\)$/, '');
        const d2 = new Date(cleaned);
        if (!isNaN(d2.getTime())) return d2;
      } catch (_) {}
      return null;
    }
    function isWithinScope(date, scope) {
      if (!date) return false;
      const now = new Date();
      const msDiff = now - date;
      switch (scope) {
        case 'today': return now.toDateString() === date.toDateString();
        case '24h':   return msDiff <= 24*60*60*1000;
        case '48h':   return msDiff <= 48*60*60*1000;
        case '7d':    return msDiff <= 7*24*60*60*1000;
        case 'all':   return true;
        default:      return false;
      }
    }

    // ========= Helpers =========
    function detectFormat(doc) {
      const isRSS  = !!doc.querySelector('rss, channel > item');
      const isAtom = !!doc.querySelector('feed, entry');
      if (isAtom) return 'atom';
      if (isRSS)  return 'rss';
      return 'unknown';
    }
    function sanitize(str) {
      if (!str) return '';
      return str.replace(/<[^>]*>/g, '').replace(/\s+/g, ' ').trim();
    }
    function getDomain(url) {
      try { return new URL(url).hostname; } catch (_) { return ''; }
    }

    function normalizeItem(node, format, feedTitle, feedUrl) {
      const getText = (el, tag) => {
        const n = el.getElementsByTagName(tag)[0];
        return n ? (n.textContent || '').trim() : '';
      };
      if (format === 'rss') {
        const title = getText(node, 'title');
        const link = getText(node, 'link');
        const pubDate = getText(node, 'pubDate') || getText(node, 'dc:date');
        const description = getText(node, 'description');
        return { title, link, description, date: parseDateAuto(pubDate), source: feedTitle || '', sourceUrl: feedUrl || '' };
      } else {
        const title = getText(node, 'title');
        let link = '';
        const links = node.getElementsByTagName('link');
        for (const L of links) {
          const href = L.getAttribute('href');
          const rel = L.getAttribute('rel') || 'alternate';
          if (href && (rel === 'alternate' || rel === null)) { link = href; break; }
          if (href && !link) link = href;
        }
        const updated = getText(node, 'updated') || getText(node, 'published');
        const summary = getText(node, 'summary') || getText(node, 'content');
        return { title, link, description: summary, date: parseDateAuto(updated), source: feedTitle || '', sourceUrl: feedUrl || '' };
      }
    }

    // ========= Fetch (concurrent + timeout) =========
    function fetchWithTimeout(url, ms) {
      const controller = new AbortController();
      const id = setTimeout(() => controller.abort(), ms);
      return fetch(url, { signal: controller.signal, method: 'GET', mode: 'cors' })
        .finally(() => clearTimeout(id));
    }
    async function fetchFeedXML(feedUrl) {
      const api = 'https://api.allorigins.win/get?url=' + encodeURIComponent(feedUrl);
      const res = await fetchWithTimeout(api, REQUEST_TIMEOUT_MS);
      if (!res.ok) throw new Error('Fetch failed: ' + res.status);
      const data = await res.json();
      return data.contents;
    }

    // Progressive processing: render and cache as each feed completes
    async function processFeed(feedUrl) {
      try {
        const xmlStr = await fetchFeedXML(feedUrl);
        const doc = new DOMParser().parseFromString(xmlStr, 'text/xml');
        const format = detectFormat(doc);
        let feedTitle = feedUrl;
        const items = [];
        if (format === 'rss') {
          const ch = doc.querySelector('channel > title');
          feedTitle = ch ? (ch.textContent || '').trim() : feedUrl;
          const nodes = [...doc.querySelectorAll('channel > item')].slice(0, MAX_ITEMS_PER_FEED);
          for (const it of nodes) items.push(normalizeItem(it, 'rss', feedTitle, feedUrl));
        } else if (format === 'atom') {
          const ft = doc.querySelector('feed > title');
          feedTitle = ft ? (ft.textContent || '').trim() : feedUrl;
          const entries = [...doc.querySelectorAll('feed > entry')].slice(0, MAX_ITEMS_PER_FEED);
          for (const en of entries) items.push(normalizeItem(en, 'atom', feedTitle, feedUrl));
        }
        for (const it of items) {
          const blob = (it.title + ' ' + it.description + ' ' + it.source).toLowerCase();
          const { tags, score } = computeTagsAndPriority(blob);
          it._tags = tags;
          it._priority = score;
        }
        return items;
      } catch (err) {
        console.error('Feed error:', feedUrl, err);
        return [];
      }
    }

    async function loadFeeds(feedUrls, onProgress) {
      setStatus('Fetching ' + feedUrls.length + ' feeds…');
      const urls = feedUrls.filter(Boolean);
      const out = [];
      let index = 0;

      async function worker() {
        while (index < urls.length) {
          const i = index++;
          const u = urls[i];
          setStatus(`Fetching (${i+1}/${urls.length}): ${u}`);
          const items = await processFeed(u);
          out.push(...items);
          if (typeof onProgress === 'function') {
            const filtered = filterItems(out, dom.scope.value, dom.keyword.value);
            const sorted = sortItems(dedupeItems(filtered), dom.sort.value);
            render(sorted);
          }
        }
      }

      const workers = Array.from({ length: Math.min(CONCURRENCY, urls.length) }, () => worker());
      await Promise.all(workers);

      setStatus('Fetched ' + out.length + ' items.');
      return dedupeItems(out);
    }

    // ========= Dedupe =========
    function dedupeItems(items) {
      const seen = new Set();
      const out = [];
      for (const it of items) {
        const guid = ((it.link || '') + '|' + (it.title || '')).toLowerCase();
        if (seen.has(guid)) continue;
        seen.add(guid);
        out.push(it);
      }
      return out;
    }

    // ========= Render =========
    function render(items) {
      dom.results.setAttribute('aria-busy', 'true');
      dom.results.innerHTML = '';

      const frag = document.createDocumentFragment();
      for (const it of items) {
        const card = document.createElement('article');
        card.className = 'card';

        // Source + domain line (show both source title and source URL/domain)
        const source = document.createElement('div');
        source.className = 'source';
        const domain = getDomain(it.link) || getDomain(it.sourceUrl);
        const srcLink = document.createElement('a');
        srcLink.href = it.sourceUrl || (domain ? `https://${domain}` : '#');
        srcLink.target = '_blank';
        srcLink.rel = 'noopener noreferrer';
        srcLink.textContent = it.source || (domain || '(unknown source)');
        source.textContent = 'Source: ';
        source.appendChild(srcLink);
        if (domain) {
          const domainSpan = document.createElement('span');
          domainSpan.textContent = ' • Domain: ' + domain;
          source.appendChild(domainSpan);
        }

        // Title
        const h3 = document.createElement('h3');
        const a = document.createElement('a');
        a.href = it.link || '#';
        a.target = '_blank';
        a.rel = 'noopener noreferrer';
        a.textContent = it.title || '(no title)';
        h3.appendChild(a);

        // Date
        const dateEl = document.createElement('div');
        dateEl.className = 'date';
        dateEl.textContent = it.date ? it.date.toLocaleString() : 'Unknown date';

        // Description
        const descEl = document.createElement('div');
        descEl.className = 'desc';
        descEl.textContent = sanitize(it.description).slice(0, 450);

        // Tags
        const tagsEl = document.createElement('div');
        tagsEl.className = 'tags';
        const tags = it._tags || [];
        for (const t of tags) {
          const tag = document.createElement('span');
          tag.className = 'tag';
          if (['Ransomware', 'Exploit', 'Zero‑Day', 'CVE', 'Breach', 'Backdoor'].includes(t)) tag.classList.add('critical');
          else if (['Malware', 'APT', 'DDoS', 'Supply Chain', 'IoC'].includes(t)) tag.classList.add('high');
          tag.textContent = t;
          tagsEl.appendChild(tag);
        }

        card.appendChild(source);
        card.appendChild(h3);
        card.appendChild(dateEl);
        card.appendChild(descEl);
        if (tagsEl.childElementCount) card.appendChild(tagsEl);

        frag.appendChild(card);
      }
      dom.results.appendChild(frag);
      dom.results.setAttribute('aria-busy', 'false');
    }

    // ========= Sort & Filter =========
    function sortItems(items, mode) {
      const byDate = (a, b) => (b.date?.getTime() || 0) - (a.date?.getTime() || 0);
      const byPriorityDate = (a, b) =>
        (b._priority || 0) - (a._priority || 0) || byDate(a, b) || (a.title || '').localeCompare(b.title || '');
      if (mode === 'priority_date') return items.sort(byPriorityDate); // cyber security items first
      if (mode === 'newest') return items.sort(byDate);
      if (mode === 'source') return items.sort((a, b) => (a.source||'').localeCompare(b.source||'') || byDate(a,b));
      if (mode === 'title')  return items.sort((a, b) => (a.title||'').localeCompare(b.title||'') || byDate(a,b));
      return items;
    }

    function filterItems(items, scope, keyword) {
      const kw = (keyword || '').trim().toLowerCase();
      const inScope = items.filter(it => isWithinScope(it.date, scope));
      const filtered = kw
        ? inScope.filter(it => ((it.title || '') + ' ' + (it.description || '') + ' ' + (it.source || '')).toLowerCase().includes(kw))
        : inScope;
      dom.countInScope.textContent = inScope.length;
      return filtered;
    }

    // ========= Cache =========
    function saveCache(feedUrls, items) {
      const data = {
        feedUrls,
        items: items.map(it => ({ ...it, date: it.date ? it.date.toISOString() : null })),
        ts: Date.now()
      };
      localStorage.setItem(CACHE_KEY, JSON.stringify(data));
      dom.updatedAt.textContent = new Date(data.ts).toLocaleString();
    }
    function loadCache() {
      const raw = localStorage.getItem(CACHE_KEY);
      if (!raw) return null;
      try {
        const data = JSON.parse(raw);
        const items = (data.items || []).map(it => ({ ...it, date: it.date ? new Date(it.date) : null }));
        dom.updatedAt.textContent = new Date(data.ts).toLocaleString();
        return { feedUrls: data.feedUrls || [], items };
      } catch (_) { return null; }
    }

    // ========= TXT Export =========
    function buildTxt(items) {
      const lines = items.map(it => {
        const t = (it.title || '').trim();
        const l = (it.link || '').trim();
        const s = (it.source || '').trim();
        const d = it.date ? it.date.toUTCString() : 'Unknown';
        return `${t}\n${l}\nSource: ${s}\nDate: ${d}\n`;
      });
      return lines.join('\n');
    }
    function downloadTxtForCurrentScope() {
      const cached = loadCache();
      if (!cached) return;
      const filtered = filterItems(cached.items, dom.scope.value, dom.keyword.value);
      const sorted = sortItems(filtered, dom.sort.value);
      const txt = buildTxt(sorted);
      const blob = new Blob([txt], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      const d = new Date();
      const dd = `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`;
      a.href = url;
      a.download = `feedgator_${dd}.txt`;
      a.rel = 'noopener';
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    // ========= Main load =========
    async function mainLoad({ fromCache = false } = {}) {
      const feedUrls = dom.feedList.value.split('\n').map(s => s.trim()).filter(Boolean);
      if (!feedUrls.length) {
        setStatus('No feeds provided. Paste RSS/Atom URLs and click Load.');
        render([]);
        return;
      }

      let items = [];
      if (fromCache) {
        const cached = loadCache();
        if (cached && JSON.stringify(cached.feedUrls) === JSON.stringify(feedUrls)) {
          setStatus('Loaded from cache.');
          items = cached.items;
        } else {
          setStatus('Cache mismatch. Fetching…');
          items = await loadFeeds(feedUrls, /*onProgress*/ (partial) => {});
          saveCache(feedUrls, items);
        }
      } else {
        items = await loadFeeds(feedUrls, /*onProgress*/ (partial) => {});
        saveCache(feedUrls, items);
      }

      const filtered = filterItems(items, dom.scope.value, dom.keyword.value);
      const sorted = sortItems(filtered, dom.sort.value);
      render(sorted);
      setStatus('Done');
    }

    // ========= Auto-refresh =========
    let refreshTimer = null;
    function startAutoRefresh() {
      stopAutoRefresh();
      refreshTimer = setInterval(async () => {
        setStatus('Auto-refreshing…');
        await mainLoad({ fromCache: false });
        setStatus('Done');
      }, AUTO_REFRESH_MINUTES * 60 * 1000);
    }
    function stopAutoRefresh() {
      if (refreshTimer) clearInterval(refreshTimer);
      refreshTimer = null;
    }

    // ========= Events =========
    dom.loadBtn.addEventListener('click', async () => {
      await mainLoad({ fromCache: false });
      startAutoRefresh();
    });
    dom.refreshBtn.addEventListener('click', async () => { await mainLoad({ fromCache: false }); });
    dom.clearCacheBtn.addEventListener('click', () => {
      localStorage.removeItem(CACHE_KEY);
      dom.updatedAt.textContent = '—';
      setStatus('Cache cleared.');
    });
    dom.keyword.addEventListener('input', () => { mainLoad({ fromCache: true }); });
    dom.scope.addEventListener('change', () => { mainLoad({ fromCache: true }); });
    dom.sort.addEventListener('change', () => { mainLoad({ fromCache: true }); });
    dom.downloadTxtBtn.addEventListener('click', downloadTxtForCurrentScope);

    // ========= First load: defaults & timer =========
    window.addEventListener('load', () => {
      if (!dom.feedList.value.trim()) {
        // Extended list of free cyber security RSS/Atom feeds for more articles
        dom.feedList.value = [
          'https://feeds.feedburner.com/TheHackersNews',
          'https://www.bleepingcomputer.com/feed/',
          'https://isc.sans.edu/rssfeed.xml',
          'https://www.darkreading.com/rss.xml',
          'https://www.cisa.gov/newsroom/alerts.xml',
          'https://www.krebsonsecurity.com/feed/',
          'https://www.rapid7.com/rss/blog/',
          'https://www.microsoft.com/en-us/security/blog/feed/',
          'https://www.securityweek.com/rss',
          'https://www.zdnet.com/topic/security/rss.xml',
          'https://www.cyberscoop.com/feed/',
          'https://www.scmagazine.com/home/security-news/feed/',
          'https://www.infosecurity-magazine.com/rss/news/',
          'https://www.schneier.com/feed/atom/',
          'https://feeds.feedburner.com/GrahamCluley',
          'https://threatpost.com/feed/',
          'https://nakedsecurity.sophos.com/feed/',
          'https://blog.talosintelligence.com/feeds/posts/default',
          'https://www.malwarebytes.com/blog/feed',
          'https://www.us-cert.gov/ncas/alerts.xml',
          'https://www.welivesecurity.com/feed/',                 /* ESET WeLiveSecurity */
          'https://unit42.paloaltonetworks.com/feed/',            /* Unit42 */
          'https://securityintelligence.com/feed/',               /* IBM Security Intelligence */
          'https://securelist.com/feed/',                         /* Kaspersky Securelist */
          'https://security.googleblog.com/atom.xml',             /* Google Security Blog */
          'https://github.blog/category/security/feed/',          /* GitHub Security Blog */
          'https://blog.qualys.com/feed'                          /* Qualys Blog */
        ].join('\n');
      }
      const cached = loadCache();
      if (cached && cached.feedUrls.length) {
        dom.feedList.value = cached.feedUrls.join('\n');
        mainLoad({ fromCache: true }).then(startAutoRefresh);
      } else {
        mainLoad({ fromCache: false }).then(startAutoRefresh);
      }
    });
  </script>
</body>
</html>
